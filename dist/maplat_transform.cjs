"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const C=11102230246251565e-32,E=134217729,at=(3+8*C)*C;function V(t,e,r,n,c){let i,f,h,g,l=e[0],y=n[0],o=0,u=0;y>l==y>-l?(i=l,l=e[++o]):(i=y,y=n[++u]);let b=0;if(o<t&&u<r)for(y>l==y>-l?(f=l+i,h=i-(f-l),l=e[++o]):(f=y+i,h=i-(f-y),y=n[++u]),i=f,h!==0&&(c[b++]=h);o<t&&u<r;)y>l==y>-l?(f=i+l,g=f-i,h=i-(f-g)+(l-g),l=e[++o]):(f=i+y,g=f-i,h=i-(f-g)+(y-g),y=n[++u]),i=f,h!==0&&(c[b++]=h);for(;o<t;)f=i+l,g=f-i,h=i-(f-g)+(l-g),l=e[++o],i=f,h!==0&&(c[b++]=h);for(;u<r;)f=i+y,g=f-i,h=i-(f-g)+(y-g),y=n[++u],i=f,h!==0&&(c[b++]=h);return(i!==0||b===0)&&(c[b++]=i),b}function ct(t,e){let r=e[0];for(let n=1;n<t;n++)r+=e[n];return r}function W(t){return new Float64Array(t)}const ut=(3+16*C)*C,ft=(2+12*C)*C,dt=(9+64*C)*C*C,R=W(4),D=W(8),q=W(12),z=W(16),P=W(4);function gt(t,e,r,n,c,i,f){let h,g,l,y,o,u,b,x,d,a,s,m,_,p,M,w,v,A;const S=t-c,O=r-c,T=e-i,k=n-i;p=S*k,u=E*S,b=u-(u-S),x=S-b,u=E*k,d=u-(u-k),a=k-d,M=x*a-(p-b*d-x*d-b*a),w=T*O,u=E*T,b=u-(u-T),x=T-b,u=E*O,d=u-(u-O),a=O-d,v=x*a-(w-b*d-x*d-b*a),s=M-v,o=M-s,R[0]=M-(s+o)+(o-v),m=p+s,o=m-p,_=p-(m-o)+(s-o),s=_-w,o=_-s,R[1]=_-(s+o)+(o-w),A=m+s,o=A-m,R[2]=m-(A-o)+(s-o),R[3]=A;let B=ct(4,R),F=ft*f;if(B>=F||-B>=F||(o=t-S,h=t-(S+o)+(o-c),o=r-O,l=r-(O+o)+(o-c),o=e-T,g=e-(T+o)+(o-i),o=n-k,y=n-(k+o)+(o-i),h===0&&g===0&&l===0&&y===0)||(F=dt*f+at*Math.abs(B),B+=S*y+k*h-(T*l+O*g),B>=F||-B>=F))return B;p=h*k,u=E*h,b=u-(u-h),x=h-b,u=E*k,d=u-(u-k),a=k-d,M=x*a-(p-b*d-x*d-b*a),w=g*O,u=E*g,b=u-(u-g),x=g-b,u=E*O,d=u-(u-O),a=O-d,v=x*a-(w-b*d-x*d-b*a),s=M-v,o=M-s,P[0]=M-(s+o)+(o-v),m=p+s,o=m-p,_=p-(m-o)+(s-o),s=_-w,o=_-s,P[1]=_-(s+o)+(o-w),A=m+s,o=A-m,P[2]=m-(A-o)+(s-o),P[3]=A;const it=V(4,R,4,P,D);p=S*y,u=E*S,b=u-(u-S),x=S-b,u=E*y,d=u-(u-y),a=y-d,M=x*a-(p-b*d-x*d-b*a),w=T*l,u=E*T,b=u-(u-T),x=T-b,u=E*l,d=u-(u-l),a=l-d,v=x*a-(w-b*d-x*d-b*a),s=M-v,o=M-s,P[0]=M-(s+o)+(o-v),m=p+s,o=m-p,_=p-(m-o)+(s-o),s=_-w,o=_-s,P[1]=_-(s+o)+(o-w),A=m+s,o=A-m,P[2]=m-(A-o)+(s-o),P[3]=A;const st=V(it,D,4,P,q);p=h*y,u=E*h,b=u-(u-h),x=h-b,u=E*y,d=u-(u-y),a=y-d,M=x*a-(p-b*d-x*d-b*a),w=g*l,u=E*g,b=u-(u-g),x=g-b,u=E*l,d=u-(u-l),a=l-d,v=x*a-(w-b*d-x*d-b*a),s=M-v,o=M-s,P[0]=M-(s+o)+(o-v),m=p+s,o=m-p,_=p-(m-o)+(s-o),s=_-w,o=_-s,P[1]=_-(s+o)+(o-w),A=m+s,o=A-m,P[2]=m-(A-o)+(s-o),P[3]=A;const ot=V(st,q,4,P,z);return z[ot-1]}function ht(t,e,r,n,c,i){const f=(e-i)*(r-c),h=(t-c)*(n-i),g=f-h,l=Math.abs(f+h);return Math.abs(g)>=ut*l?g:-gt(t,e,r,n,c,i,l)}function lt(t,e){var r,n,c=0,i,f,h,g,l,y,o,u=t[0],b=t[1],x=e.length;for(r=0;r<x;r++){n=0;var d=e[r],a=d.length-1;if(y=d[0],y[0]!==d[a][0]&&y[1]!==d[a][1])throw new Error("First and last coordinates in a ring must be the same");for(f=y[0]-u,h=y[1]-b,n;n<a;n++){if(o=d[n+1],g=o[0]-u,l=o[1]-b,h===0&&l===0){if(g<=0&&f>=0||f<=0&&g>=0)return 0}else if(l>=0&&h<=0||l<=0&&h>=0){if(i=ht(f,g,h,l,0,0),i===0)return 0;(i>0&&l>0&&h<=0||i<0&&l<=0&&h>0)&&c++}y=o,h=l,f=g}}return c%2!==0}function H(t,e,r={}){const n={type:"Feature"};return(r.id===0||r.id)&&(n.id=r.id),r.bbox&&(n.bbox=r.bbox),n.properties=e||{},n.geometry=t,n}function X(t,e,r={}){if(!t)throw new Error("coordinates is required");if(!Array.isArray(t))throw new Error("coordinates must be an Array");if(t.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!G(t[0])||!G(t[1]))throw new Error("coordinates must contain numbers");return H({type:"Point",coordinates:t},e,r)}function Z(t,e,r={}){for(const c of t){if(c.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");if(c[c.length-1].length!==c[0].length)throw new Error("First and last Position are not equivalent.");for(let i=0;i<c[c.length-1].length;i++)if(c[c.length-1][i]!==c[0][i])throw new Error("First and last Position are not equivalent.")}return H({type:"Polygon",coordinates:t},e,r)}function U(t,e={}){const r={type:"FeatureCollection"};return e.id&&(r.id=e.id),e.bbox&&(r.bbox=e.bbox),r.features=t,r}function G(t){return!isNaN(t)&&t!==null&&!Array.isArray(t)}function yt(t){if(!t)throw new Error("coord is required");if(!Array.isArray(t)){if(t.type==="Feature"&&t.geometry!==null&&t.geometry.type==="Point")return[...t.geometry.coordinates];if(t.type==="Point")return[...t.coordinates]}if(Array.isArray(t)&&t.length>=2&&!Array.isArray(t[0])&&!Array.isArray(t[1]))return[...t];throw new Error("coord must be GeoJSON Point or an Array of numbers")}function j(t){if(Array.isArray(t))return t;if(t.type==="Feature"){if(t.geometry!==null)return t.geometry.coordinates}else if(t.coordinates)return t.coordinates;throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")}function bt(t){return t.type==="Feature"?t.geometry:t}function mt(t,e,r={}){if(!t)throw new Error("point is required");if(!e)throw new Error("polygon is required");const n=yt(t),c=bt(e),i=c.type,f=e.bbox;let h=c.coordinates;if(f&&wt(n,f)===!1)return!1;i==="Polygon"&&(h=[h]);let g=!1;for(var l=0;l<h.length;++l){const y=lt(n,h[l]);if(y===0)return!r.ignoreBoundary;y&&(g=!0)}return g}function wt(t,e){return e[0]<=t[0]&&e[1]<=t[1]&&e[2]>=t[0]&&e[3]>=t[1]}var Y=mt;function J(t,e){for(let r=0;r<e.features.length;r++)if(Y(t,e.features[r]))return e.features[r]}function tt(t,e,r){const n=e.geometry.coordinates[0][0],c=e.geometry.coordinates[0][1],i=e.geometry.coordinates[0][2],f=t.geometry.coordinates,h=e.properties.a.geom,g=e.properties.b.geom,l=e.properties.c.geom,y=[c[0]-n[0],c[1]-n[1]],o=[i[0]-n[0],i[1]-n[1]],u=[f[0]-n[0],f[1]-n[1]],b=[g[0]-h[0],g[1]-h[1]],x=[l[0]-h[0],l[1]-h[1]];let d=(o[1]*u[0]-o[0]*u[1])/(y[0]*o[1]-y[1]*o[0]),a=(y[0]*u[1]-y[1]*u[0])/(y[0]*o[1]-y[1]*o[0]);if(r){const s=r[e.properties.a.index],m=r[e.properties.b.index],_=r[e.properties.c.index];let p;if(d<0||a<0||1-d-a<0){const M=d/(d+a),w=a/(d+a);p=d/m/(M/m+w/_),a=a/_/(M/m+w/_)}else p=d/m/(d/m+a/_+(1-d-a)/s),a=a/_/(d/m+a/_+(1-d-a)/s);d=p}return[d*b[0]+a*x[0]+h[0],d*b[1]+a*x[1]+h[1]]}function xt(t,e,r,n){const c=t.geometry.coordinates,i=r.geometry.coordinates,f=Math.atan2(c[0]-i[0],c[1]-i[1]),h=_t(f,e[0]);if(h===void 0)throw new Error("Unable to determine vertex index");const g=e[1][h];return tt(t,g.features[0],n)}function et(t,e,r,n,c,i,f,h){let g;if(f&&(g=J(t,U([f]))),!g){if(r){const l=t.geometry.coordinates,y=r.gridNum,o=r.xOrigin,u=r.yOrigin,b=r.xUnit,x=r.yUnit,d=r.gridCache,a=N(l[0],o,b,y),s=N(l[1],u,x,y),m=d[a]?d[a][s]?d[a][s]:[]:[];e=U(m.map(_=>e.features[_]))}g=J(t,e)}return h&&h(g),g?tt(t,g,i):xt(t,n,c,i)}function N(t,e,r,n){let c=Math.floor((t-e)/r);return c>=n&&(c=n-1),c}function _t(t,e){let r=K(t-e[0]),n=Math.PI*2,c;for(let i=0;i<e.length;i++){const f=(i+1)%e.length,h=K(t-e[f]),g=Math.min(Math.abs(r),Math.abs(h));r*h<=0&&g<n&&(n=g,c=i),r=h}return c}function K(t,e=!1){const r=e?function(n){return!(n>=0&&n<Math.PI*2)}:function(n){return!(n>-1*Math.PI&&n<=Math.PI)};for(;r(t);)t=t+2*Math.PI*(t>0?-1:1);return t}function rt(t,e){return e&&e>=2.00703||Array.isArray(t[0])?t:t.map(r=>[r.illstNodes,r.mercNodes,r.startEnd])}function pt(t){const e=t.features;for(let r=0;r<e.length;r++){const n=e[r];`${n.properties.a.index}`.substring(0,1)==="b"&&`${n.properties.b.index}`.substring(0,1)==="b"?e[r]={geometry:{type:"Polygon",coordinates:[[n.geometry.coordinates[0][2],n.geometry.coordinates[0][0],n.geometry.coordinates[0][1],n.geometry.coordinates[0][2]]]},properties:{a:{geom:n.properties.c.geom,index:n.properties.c.index},b:{geom:n.properties.a.geom,index:n.properties.a.index},c:{geom:n.properties.b.geom,index:n.properties.b.index}},type:"Feature"}:`${n.properties.c.index}`.substring(0,1)==="b"&&`${n.properties.a.index}`.substring(0,1)==="b"&&(e[r]={geometry:{type:"Polygon",coordinates:[[n.geometry.coordinates[0][1],n.geometry.coordinates[0][2],n.geometry.coordinates[0][0],n.geometry.coordinates[0][1]]]},properties:{a:{geom:n.properties.b.geom,index:n.properties.b.index},b:{geom:n.properties.c.geom,index:n.properties.c.index},c:{geom:n.properties.a.geom,index:n.properties.a.index}},type:"Feature"})}return t}function vt(t){const e=["a","b","c","a"].map(i=>t.properties[i].geom),r=t.geometry.coordinates[0],n=t.properties,c={a:{geom:r[0],index:n.a.index},b:{geom:r[1],index:n.b.index},c:{geom:r[2],index:n.c.index}};return Z([e],c)}function Mt(t){const e=[0,1,2,0].map(n=>t[n][0][0]),r={a:{geom:t[0][0][1],index:t[0][1]},b:{geom:t[1][0][1],index:t[1][1]},c:{geom:t[2][0][1],index:t[2][1]}};return Z([e],r)}function L(t,e,r,n,c,i=!1,f){const h=t.map(g=>{(!f||f<2.00703)&&(g=nt(g));const l=isFinite(g)?e[g]:g==="c"?n:g==="b0"?c[0]:g==="b1"?c[1]:g==="b2"?c[2]:g==="b3"?c[3]:function(){const y=g.match(/e(\d+)/);if(y){const o=parseInt(y[1]);return r[o]}throw"Bad index value for indexesToTri"}();return i?[[l[1],l[0]],g]:[[l[0],l[1]],g]});return Mt(h)}function nt(t){return typeof t=="number"?t:t.replace(/^(c|e|b)(?:ent|dgeNode|box)(\d+)?$/,"$1$2")}const $=2.00703;function At(t){return!!(t.version||!t.tins&&t.points&&t.tins_points)}function Et(t){return{points:t.points,pointsWeightBuffer:St(t),strictStatus:Ot(t),verticesParams:Tt(t),centroid:kt(t),edges:rt(t.edges||[]),edgeNodes:t.edgeNodes||[],tins:It(t),kinks:Nt(t.kinks_points),yaxisMode:t.yaxisMode??"invert",strictMode:t.strictMode??"auto",vertexMode:t.vertexMode,bounds:t.bounds,boundsPolygon:t.boundsPolygon,wh:t.wh,xy:t.bounds?t.xy:[0,0]}}function Pt(t){const e=Bt(t),r=e.tins;return{compiled:e,tins:r,points:Ct(r),strictStatus:e.strict_status,pointsWeightBuffer:e.weight_buffer,verticesParams:e.vertices_params,centroid:e.centroid,kinks:e.kinks}}function St(t){return!t.version||t.version<$?["forw","bakw"].reduce((e,r)=>{const n=t.weight_buffer[r];return n&&(e[r]=Object.keys(n).reduce((c,i)=>{const f=nt(i);return c[f]=n[i],c},{})),e},{}):t.weight_buffer}function Ot(t){return t.strict_status?t.strict_status:t.kinks_points?"strict_error":t.tins_points.length===2?"loose":"strict"}function Tt(t){const e={forw:[t.vertices_params[0]],bakw:[t.vertices_params[1]]};return e.forw[1]=Q(t,!1),e.bakw[1]=Q(t,!0),e}function Q(t,e){return[0,1,2,3].map(r=>{const n=(r+1)%4,c=L(["c",`b${r}`,`b${n}`],t.points,t.edgeNodes||[],t.centroid_point,t.vertices_points,e,$);return U([c])})}function kt(t){return{forw:X(t.centroid_point[0],{target:{geom:t.centroid_point[1],index:"c"}}),bakw:X(t.centroid_point[1],{target:{geom:t.centroid_point[0],index:"c"}})}}function It(t){const e=t.tins_points.length===1?0:1;return{forw:U(t.tins_points[0].map(r=>L(r,t.points,t.edgeNodes||[],t.centroid_point,t.vertices_points,!1,t.version))),bakw:U(t.tins_points[e].map(r=>L(r,t.points,t.edgeNodes||[],t.centroid_point,t.vertices_points,!0,t.version)))}}function Nt(t){if(t)return{bakw:U(t.map(e=>X(e)))}}function Bt(t){return JSON.parse(JSON.stringify(t).replace('"cent"','"c"').replace(/"bbox(\d+)"/g,'"b$1"'))}function Ct(t){const e=[],r=t.forw.features;for(let n=0;n<r.length;n++){const c=r[n];["a","b","c"].map((i,f)=>{const h=c.geometry.coordinates[0][f],g=c.properties[i].geom,l=c.properties[i].index;typeof l=="number"&&(e[l]=[h,g])})}return e}const Rt=$;class I{static VERTEX_PLAIN="plain";static VERTEX_BIRDEYE="birdeye";static MODE_STRICT="strict";static MODE_AUTO="auto";static MODE_LOOSE="loose";static STATUS_STRICT="strict";static STATUS_ERROR="strict_error";static STATUS_LOOSE="loose";static YAXIS_FOLLOW="follow";static YAXIS_INVERT="invert";points=[];pointsWeightBuffer;strict_status;vertices_params;centroid;edgeNodes;edges;tins;kinks;yaxisMode=I.YAXIS_INVERT;strictMode=I.MODE_AUTO;vertexMode=I.VERTEX_PLAIN;bounds;boundsPolygon;wh;xy;indexedTins;stateFull=!1;stateTriangle;stateBackward;constructor(){}setCompiled(e){if(At(e)){this.applyModernState(Et(e));return}this.applyLegacyState(Pt(e))}applyModernState(e){this.points=e.points,this.pointsWeightBuffer=e.pointsWeightBuffer,this.strict_status=e.strictStatus,this.vertices_params=e.verticesParams,this.centroid=e.centroid,this.edges=e.edges,this.edgeNodes=e.edgeNodes||[],this.tins=e.tins,this.addIndexedTin(),this.kinks=e.kinks,this.yaxisMode=e.yaxisMode??I.YAXIS_INVERT,this.vertexMode=e.vertexMode??I.VERTEX_PLAIN,this.strictMode=e.strictMode??I.MODE_AUTO,e.bounds?(this.bounds=e.bounds,this.boundsPolygon=e.boundsPolygon,this.xy=e.xy,this.wh=e.wh):(this.bounds=void 0,this.boundsPolygon=void 0,this.xy=e.xy??[0,0],e.wh&&(this.wh=e.wh))}applyLegacyState(e){this.tins=e.tins,this.addIndexedTin(),this.strict_status=e.strictStatus,this.pointsWeightBuffer=e.pointsWeightBuffer,this.vertices_params=e.verticesParams,this.centroid=e.centroid,this.kinks=e.kinks,this.points=e.points}addIndexedTin(){const e=this.tins,r=e.forw,n=e.bakw,c=Math.ceil(Math.sqrt(r.features.length));if(c<3){this.indexedTins=void 0;return}let i=[],f=[];const h=r.features.map(d=>{let a=[];return j(d)[0].map(s=>{i.length===0?i=[Array.from(s),Array.from(s)]:(s[0]<i[0][0]&&(i[0][0]=s[0]),s[0]>i[1][0]&&(i[1][0]=s[0]),s[1]<i[0][1]&&(i[0][1]=s[1]),s[1]>i[1][1]&&(i[1][1]=s[1])),a.length===0?a=[Array.from(s),Array.from(s)]:(s[0]<a[0][0]&&(a[0][0]=s[0]),s[0]>a[1][0]&&(a[1][0]=s[0]),s[1]<a[0][1]&&(a[0][1]=s[1]),s[1]>a[1][1]&&(a[1][1]=s[1]))}),a}),g=(i[1][0]-i[0][0])/c,l=(i[1][1]-i[0][1])/c,y=h.reduce((d,a,s)=>{const m=N(a[0][0],i[0][0],g,c),_=N(a[1][0],i[0][0],g,c),p=N(a[0][1],i[0][1],l,c),M=N(a[1][1],i[0][1],l,c);for(let w=m;w<=_;w++){d[w]||(d[w]=[]);for(let v=p;v<=M;v++)d[w][v]||(d[w][v]=[]),d[w][v].push(s)}return d},[]),o=n.features.map(d=>{let a=[];return j(d)[0].map(s=>{f.length===0?f=[Array.from(s),Array.from(s)]:(s[0]<f[0][0]&&(f[0][0]=s[0]),s[0]>f[1][0]&&(f[1][0]=s[0]),s[1]<f[0][1]&&(f[0][1]=s[1]),s[1]>f[1][1]&&(f[1][1]=s[1])),a.length===0?a=[Array.from(s),Array.from(s)]:(s[0]<a[0][0]&&(a[0][0]=s[0]),s[0]>a[1][0]&&(a[1][0]=s[0]),s[1]<a[0][1]&&(a[0][1]=s[1]),s[1]>a[1][1]&&(a[1][1]=s[1]))}),a}),u=(f[1][0]-f[0][0])/c,b=(f[1][1]-f[0][1])/c,x=o.reduce((d,a,s)=>{const m=N(a[0][0],f[0][0],u,c),_=N(a[1][0],f[0][0],u,c),p=N(a[0][1],f[0][1],b,c),M=N(a[1][1],f[0][1],b,c);for(let w=m;w<=_;w++){d[w]||(d[w]=[]);for(let v=p;v<=M;v++)d[w][v]||(d[w][v]=[]),d[w][v].push(s)}return d},[]);this.indexedTins={forw:{gridNum:c,xOrigin:i[0][0],yOrigin:i[0][1],xUnit:g,yUnit:l,gridCache:y},bakw:{gridNum:c,xOrigin:f[0][0],yOrigin:f[0][1],xUnit:u,yUnit:b,gridCache:x}}}transform(e,r,n){if(r&&this.strict_status==I.STATUS_ERROR)throw'Backward transform is not allowed if strict_status == "strict_error"';this.yaxisMode==I.YAXIS_FOLLOW&&r&&(e=[e[0],-1*e[1]]);const c=X(e);if(this.bounds&&!r&&!n&&!Y(c,this.boundsPolygon))return!1;const i=r?this.tins.bakw:this.tins.forw,f=r?this.indexedTins.bakw:this.indexedTins.forw,h=r?this.vertices_params.bakw:this.vertices_params.forw,g=r?this.centroid.bakw:this.centroid.forw,l=r?this.pointsWeightBuffer.bakw:this.pointsWeightBuffer.forw;let y,o;this.stateFull&&(this.stateBackward==r?y=this.stateTriangle:(this.stateBackward=r,this.stateTriangle=void 0),o=b=>{this.stateTriangle=b});let u=et(c,i,f,h,g,l,y,o);if(this.bounds&&r&&!n){const b=X(u);if(!Y(b,this.boundsPolygon))return!1}else this.yaxisMode==I.YAXIS_FOLLOW&&!r&&(u=[u[0],-1*u[1]]);return u}}exports.Transform=I;exports.counterTri=vt;exports.format_version=Rt;exports.normalizeEdges=rt;exports.rotateVerticesTriangle=pt;exports.transformArr=et;
