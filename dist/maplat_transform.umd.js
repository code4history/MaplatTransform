(function(S,T){typeof exports=="object"&&typeof module<"u"?T(exports):typeof define=="function"&&define.amd?define(["exports"],T):(S=typeof globalThis<"u"?globalThis:S||self,T(S.maplat_transform={}))})(this,function(S){"use strict";const T=11102230246251565e-32,A=134217729,st=(3+8*T)*T;function Y(t,e,r,n,c){let i,f,g,h,l=e[0],y=n[0],o=0,u=0;y>l==y>-l?(i=l,l=e[++o]):(i=y,y=n[++u]);let b=0;if(o<t&&u<r)for(y>l==y>-l?(f=l+i,g=i-(f-l),l=e[++o]):(f=y+i,g=i-(f-y),y=n[++u]),i=f,g!==0&&(c[b++]=g);o<t&&u<r;)y>l==y>-l?(f=i+l,h=f-i,g=i-(f-h)+(l-h),l=e[++o]):(f=i+y,h=f-i,g=i-(f-h)+(y-h),y=n[++u]),i=f,g!==0&&(c[b++]=g);for(;o<t;)f=i+l,h=f-i,g=i-(f-h)+(l-h),l=e[++o],i=f,g!==0&&(c[b++]=g);for(;u<r;)f=i+y,h=f-i,g=i-(f-h)+(y-h),y=n[++u],i=f,g!==0&&(c[b++]=g);return(i!==0||b===0)&&(c[b++]=i),b}function ot(t,e){let r=e[0];for(let n=1;n<t;n++)r+=e[n];return r}function X(t){return new Float64Array(t)}const at=(3+16*T)*T,ct=(2+12*T)*T,ut=(9+64*T)*T*T,U=X(4),q=X(8),z=X(12),j=X(16),P=X(4);function ft(t,e,r,n,c,i,f){let g,h,l,y,o,u,b,x,d,a,s,m,_,p,M,w,v,E;const k=t-c,I=r-c,N=e-i,B=n-i;p=k*B,u=A*k,b=u-(u-k),x=k-b,u=A*B,d=u-(u-B),a=B-d,M=x*a-(p-b*d-x*d-b*a),w=N*I,u=A*N,b=u-(u-N),x=N-b,u=A*I,d=u-(u-I),a=I-d,v=x*a-(w-b*d-x*d-b*a),s=M-v,o=M-s,U[0]=M-(s+o)+(o-v),m=p+s,o=m-p,_=p-(m-o)+(s-o),s=_-w,o=_-s,U[1]=_-(s+o)+(o-w),E=m+s,o=E-m,U[2]=m-(E-o)+(s-o),U[3]=E;let R=ot(4,U),V=ct*f;if(R>=V||-R>=V||(o=t-k,g=t-(k+o)+(o-c),o=r-I,l=r-(I+o)+(o-c),o=e-N,h=e-(N+o)+(o-i),o=n-B,y=n-(B+o)+(o-i),g===0&&h===0&&l===0&&y===0)||(V=ut*f+st*Math.abs(R),R+=k*y+B*g-(N*l+I*h),R>=V||-R>=V))return R;p=g*B,u=A*g,b=u-(u-g),x=g-b,u=A*B,d=u-(u-B),a=B-d,M=x*a-(p-b*d-x*d-b*a),w=h*I,u=A*h,b=u-(u-h),x=h-b,u=A*I,d=u-(u-I),a=I-d,v=x*a-(w-b*d-x*d-b*a),s=M-v,o=M-s,P[0]=M-(s+o)+(o-v),m=p+s,o=m-p,_=p-(m-o)+(s-o),s=_-w,o=_-s,P[1]=_-(s+o)+(o-w),E=m+s,o=E-m,P[2]=m-(E-o)+(s-o),P[3]=E;const Ct=Y(4,U,4,P,q);p=k*y,u=A*k,b=u-(u-k),x=k-b,u=A*y,d=u-(u-y),a=y-d,M=x*a-(p-b*d-x*d-b*a),w=N*l,u=A*N,b=u-(u-N),x=N-b,u=A*l,d=u-(u-l),a=l-d,v=x*a-(w-b*d-x*d-b*a),s=M-v,o=M-s,P[0]=M-(s+o)+(o-v),m=p+s,o=m-p,_=p-(m-o)+(s-o),s=_-w,o=_-s,P[1]=_-(s+o)+(o-w),E=m+s,o=E-m,P[2]=m-(E-o)+(s-o),P[3]=E;const Rt=Y(Ct,q,4,P,z);p=g*y,u=A*g,b=u-(u-g),x=g-b,u=A*y,d=u-(u-y),a=y-d,M=x*a-(p-b*d-x*d-b*a),w=h*l,u=A*h,b=u-(u-h),x=h-b,u=A*l,d=u-(u-l),a=l-d,v=x*a-(w-b*d-x*d-b*a),s=M-v,o=M-s,P[0]=M-(s+o)+(o-v),m=p+s,o=m-p,_=p-(m-o)+(s-o),s=_-w,o=_-s,P[1]=_-(s+o)+(o-w),E=m+s,o=E-m,P[2]=m-(E-o)+(s-o),P[3]=E;const Ut=Y(Rt,z,4,P,j);return j[Ut-1]}function dt(t,e,r,n,c,i){const f=(e-i)*(r-c),g=(t-c)*(n-i),h=f-g,l=Math.abs(f+g);return Math.abs(h)>=at*l?h:-ft(t,e,r,n,c,i,l)}function ht(t,e){var r,n,c=0,i,f,g,h,l,y,o,u=t[0],b=t[1],x=e.length;for(r=0;r<x;r++){n=0;var d=e[r],a=d.length-1;if(y=d[0],y[0]!==d[a][0]&&y[1]!==d[a][1])throw new Error("First and last coordinates in a ring must be the same");for(f=y[0]-u,g=y[1]-b,n;n<a;n++){if(o=d[n+1],h=o[0]-u,l=o[1]-b,g===0&&l===0){if(h<=0&&f>=0||f<=0&&h>=0)return 0}else if(l>=0&&g<=0||l<=0&&g>=0){if(i=dt(f,h,g,l,0,0),i===0)return 0;(i>0&&l>0&&g<=0||i<0&&l<=0&&g>0)&&c++}y=o,g=l,f=h}}return c%2!==0}function G(t,e,r={}){const n={type:"Feature"};return(r.id===0||r.id)&&(n.id=r.id),r.bbox&&(n.bbox=r.bbox),n.properties=e||{},n.geometry=t,n}function W(t,e,r={}){if(!t)throw new Error("coordinates is required");if(!Array.isArray(t))throw new Error("coordinates must be an Array");if(t.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!K(t[0])||!K(t[1]))throw new Error("coordinates must contain numbers");return G({type:"Point",coordinates:t},e,r)}function J(t,e,r={}){for(const c of t){if(c.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");if(c[c.length-1].length!==c[0].length)throw new Error("First and last Position are not equivalent.");for(let i=0;i<c[c.length-1].length;i++)if(c[c.length-1][i]!==c[0][i])throw new Error("First and last Position are not equivalent.")}return G({type:"Polygon",coordinates:t},e,r)}function F(t,e={}){const r={type:"FeatureCollection"};return e.id&&(r.id=e.id),e.bbox&&(r.bbox=e.bbox),r.features=t,r}function K(t){return!isNaN(t)&&t!==null&&!Array.isArray(t)}function gt(t){if(!t)throw new Error("coord is required");if(!Array.isArray(t)){if(t.type==="Feature"&&t.geometry!==null&&t.geometry.type==="Point")return[...t.geometry.coordinates];if(t.type==="Point")return[...t.coordinates]}if(Array.isArray(t)&&t.length>=2&&!Array.isArray(t[0])&&!Array.isArray(t[1]))return[...t];throw new Error("coord must be GeoJSON Point or an Array of numbers")}function Q(t){if(Array.isArray(t))return t;if(t.type==="Feature"){if(t.geometry!==null)return t.geometry.coordinates}else if(t.coordinates)return t.coordinates;throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")}function lt(t){return t.type==="Feature"?t.geometry:t}function yt(t,e,r={}){if(!t)throw new Error("point is required");if(!e)throw new Error("polygon is required");const n=gt(t),c=lt(e),i=c.type,f=e.bbox;let g=c.coordinates;if(f&&bt(n,f)===!1)return!1;i==="Polygon"&&(g=[g]);let h=!1;for(var l=0;l<g.length;++l){const y=ht(n,g[l]);if(y===0)return!r.ignoreBoundary;y&&(h=!0)}return h}function bt(t,e){return e[0]<=t[0]&&e[1]<=t[1]&&e[2]>=t[0]&&e[3]>=t[1]}var L=yt;function H(t,e){for(let r=0;r<e.features.length;r++)if(L(t,e.features[r]))return e.features[r]}function Z(t,e,r){const n=e.geometry.coordinates[0][0],c=e.geometry.coordinates[0][1],i=e.geometry.coordinates[0][2],f=t.geometry.coordinates,g=e.properties.a.geom,h=e.properties.b.geom,l=e.properties.c.geom,y=[c[0]-n[0],c[1]-n[1]],o=[i[0]-n[0],i[1]-n[1]],u=[f[0]-n[0],f[1]-n[1]],b=[h[0]-g[0],h[1]-g[1]],x=[l[0]-g[0],l[1]-g[1]];let d=(o[1]*u[0]-o[0]*u[1])/(y[0]*o[1]-y[1]*o[0]),a=(y[0]*u[1]-y[1]*u[0])/(y[0]*o[1]-y[1]*o[0]);if(r){const s=r[e.properties.a.index],m=r[e.properties.b.index],_=r[e.properties.c.index];let p;if(d<0||a<0||1-d-a<0){const M=d/(d+a),w=a/(d+a);p=d/m/(M/m+w/_),a=a/_/(M/m+w/_)}else p=d/m/(d/m+a/_+(1-d-a)/s),a=a/_/(d/m+a/_+(1-d-a)/s);d=p}return[d*b[0]+a*x[0]+g[0],d*b[1]+a*x[1]+g[1]]}function mt(t,e,r,n){const c=t.geometry.coordinates,i=r.geometry.coordinates,f=Math.atan2(c[0]-i[0],c[1]-i[1]),g=wt(f,e[0]);if(g===void 0)throw new Error("Unable to determine vertex index");const h=e[1][g];return Z(t,h.features[0],n)}function tt(t,e,r,n,c,i,f,g){let h;if(f&&(h=H(t,F([f]))),!h){if(r){const l=t.geometry.coordinates,y=r.gridNum,o=r.xOrigin,u=r.yOrigin,b=r.xUnit,x=r.yUnit,d=r.gridCache,a=C(l[0],o,b,y),s=C(l[1],u,x,y),m=d[a]?d[a][s]?d[a][s]:[]:[];e=F(m.map(_=>e.features[_]))}h=H(t,e)}return g&&g(h),h?Z(t,h,i):mt(t,n,c,i)}function C(t,e,r,n){let c=Math.floor((t-e)/r);return c>=n&&(c=n-1),c}function wt(t,e){let r=et(t-e[0]),n=Math.PI*2,c;for(let i=0;i<e.length;i++){const f=(i+1)%e.length,g=et(t-e[f]),h=Math.min(Math.abs(r),Math.abs(g));r*g<=0&&h<n&&(n=h,c=i),r=g}return c}function et(t,e=!1){const r=e?function(n){return!(n>=0&&n<Math.PI*2)}:function(n){return!(n>-1*Math.PI&&n<=Math.PI)};for(;r(t);)t=t+2*Math.PI*(t>0?-1:1);return t}function rt(t,e){return e&&e>=2.00703||Array.isArray(t[0])?t:t.map(r=>[r.illstNodes,r.mercNodes,r.startEnd])}function xt(t){const e=t.features;for(let r=0;r<e.length;r++){const n=e[r];`${n.properties.a.index}`.substring(0,1)==="b"&&`${n.properties.b.index}`.substring(0,1)==="b"?e[r]={geometry:{type:"Polygon",coordinates:[[n.geometry.coordinates[0][2],n.geometry.coordinates[0][0],n.geometry.coordinates[0][1],n.geometry.coordinates[0][2]]]},properties:{a:{geom:n.properties.c.geom,index:n.properties.c.index},b:{geom:n.properties.a.geom,index:n.properties.a.index},c:{geom:n.properties.b.geom,index:n.properties.b.index}},type:"Feature"}:`${n.properties.c.index}`.substring(0,1)==="b"&&`${n.properties.a.index}`.substring(0,1)==="b"&&(e[r]={geometry:{type:"Polygon",coordinates:[[n.geometry.coordinates[0][1],n.geometry.coordinates[0][2],n.geometry.coordinates[0][0],n.geometry.coordinates[0][1]]]},properties:{a:{geom:n.properties.b.geom,index:n.properties.b.index},b:{geom:n.properties.c.geom,index:n.properties.c.index},c:{geom:n.properties.a.geom,index:n.properties.a.index}},type:"Feature"})}return t}function _t(t){const e=["a","b","c","a"].map(i=>t.properties[i].geom),r=t.geometry.coordinates[0],n=t.properties,c={a:{geom:r[0],index:n.a.index},b:{geom:r[1],index:n.b.index},c:{geom:r[2],index:n.c.index}};return J([e],c)}function pt(t){const e=[0,1,2,0].map(n=>t[n][0][0]),r={a:{geom:t[0][0][1],index:t[0][1]},b:{geom:t[1][0][1],index:t[1][1]},c:{geom:t[2][0][1],index:t[2][1]}};return J([e],r)}function $(t,e,r,n,c,i=!1,f){const g=t.map(h=>{(!f||f<2.00703)&&(h=nt(h));const l=isFinite(h)?e[h]:h==="c"?n:h==="b0"?c[0]:h==="b1"?c[1]:h==="b2"?c[2]:h==="b3"?c[3]:function(){const y=h.match(/e(\d+)/);if(y){const o=parseInt(y[1]);return r[o]}throw"Bad index value for indexesToTri"}();return i?[[l[1],l[0]],h]:[[l[0],l[1]],h]});return pt(g)}function nt(t){return typeof t=="number"?t:t.replace(/^(c|e|b)(?:ent|dgeNode|box)(\d+)?$/,"$1$2")}const D=2.00703;function vt(t){return!!(t.version||!t.tins&&t.points&&t.tins_points)}function Mt(t){return{points:t.points,pointsWeightBuffer:Et(t),strictStatus:Pt(t),verticesParams:Tt(t),centroid:St(t),edges:rt(t.edges||[]),edgeNodes:t.edgeNodes||[],tins:Ot(t),kinks:kt(t.kinks_points),yaxisMode:t.yaxisMode??"invert",strictMode:t.strictMode??"auto",vertexMode:t.vertexMode,bounds:t.bounds,boundsPolygon:t.boundsPolygon,wh:t.wh,xy:t.bounds?t.xy:[0,0]}}function At(t){const e=It(t),r=e.tins;return{compiled:e,tins:r,points:Nt(r),strictStatus:e.strict_status,pointsWeightBuffer:e.weight_buffer,verticesParams:e.vertices_params,centroid:e.centroid,kinks:e.kinks}}function Et(t){return!t.version||t.version<D?["forw","bakw"].reduce((e,r)=>{const n=t.weight_buffer[r];return n&&(e[r]=Object.keys(n).reduce((c,i)=>{const f=nt(i);return c[f]=n[i],c},{})),e},{}):t.weight_buffer}function Pt(t){return t.strict_status?t.strict_status:t.kinks_points?"strict_error":t.tins_points.length===2?"loose":"strict"}function Tt(t){const e={forw:[t.vertices_params[0]],bakw:[t.vertices_params[1]]};return e.forw[1]=it(t,!1),e.bakw[1]=it(t,!0),e}function it(t,e){return[0,1,2,3].map(r=>{const n=(r+1)%4,c=$(["c",`b${r}`,`b${n}`],t.points,t.edgeNodes||[],t.centroid_point,t.vertices_points,e,D);return F([c])})}function St(t){return{forw:W(t.centroid_point[0],{target:{geom:t.centroid_point[1],index:"c"}}),bakw:W(t.centroid_point[1],{target:{geom:t.centroid_point[0],index:"c"}})}}function Ot(t){const e=t.tins_points.length===1?0:1;return{forw:F(t.tins_points[0].map(r=>$(r,t.points,t.edgeNodes||[],t.centroid_point,t.vertices_points,!1,t.version))),bakw:F(t.tins_points[e].map(r=>$(r,t.points,t.edgeNodes||[],t.centroid_point,t.vertices_points,!0,t.version)))}}function kt(t){if(t)return{bakw:F(t.map(e=>W(e)))}}function It(t){return JSON.parse(JSON.stringify(t).replace('"cent"','"c"').replace(/"bbox(\d+)"/g,'"b$1"'))}function Nt(t){const e=[],r=t.forw.features;for(let n=0;n<r.length;n++){const c=r[n];["a","b","c"].map((i,f)=>{const g=c.geometry.coordinates[0][f],h=c.properties[i].geom,l=c.properties[i].index;typeof l=="number"&&(e[l]=[g,h])})}return e}const Bt=D;class O{static VERTEX_PLAIN="plain";static VERTEX_BIRDEYE="birdeye";static MODE_STRICT="strict";static MODE_AUTO="auto";static MODE_LOOSE="loose";static STATUS_STRICT="strict";static STATUS_ERROR="strict_error";static STATUS_LOOSE="loose";static YAXIS_FOLLOW="follow";static YAXIS_INVERT="invert";points=[];pointsWeightBuffer;strict_status;vertices_params;centroid;edgeNodes;edges;tins;kinks;yaxisMode=O.YAXIS_INVERT;strictMode=O.MODE_AUTO;vertexMode=O.VERTEX_PLAIN;bounds;boundsPolygon;wh;xy;indexedTins;stateFull=!1;stateTriangle;stateBackward;constructor(){}setCompiled(e){if(vt(e)){this.applyModernState(Mt(e));return}this.applyLegacyState(At(e))}applyModernState(e){this.points=e.points,this.pointsWeightBuffer=e.pointsWeightBuffer,this.strict_status=e.strictStatus,this.vertices_params=e.verticesParams,this.centroid=e.centroid,this.edges=e.edges,this.edgeNodes=e.edgeNodes||[],this.tins=e.tins,this.addIndexedTin(),this.kinks=e.kinks,this.yaxisMode=e.yaxisMode??O.YAXIS_INVERT,this.vertexMode=e.vertexMode??O.VERTEX_PLAIN,this.strictMode=e.strictMode??O.MODE_AUTO,e.bounds?(this.bounds=e.bounds,this.boundsPolygon=e.boundsPolygon,this.xy=e.xy,this.wh=e.wh):(this.bounds=void 0,this.boundsPolygon=void 0,this.xy=e.xy??[0,0],e.wh&&(this.wh=e.wh))}applyLegacyState(e){this.tins=e.tins,this.addIndexedTin(),this.strict_status=e.strictStatus,this.pointsWeightBuffer=e.pointsWeightBuffer,this.vertices_params=e.verticesParams,this.centroid=e.centroid,this.kinks=e.kinks,this.points=e.points}addIndexedTin(){const e=this.tins,r=e.forw,n=e.bakw,c=Math.ceil(Math.sqrt(r.features.length));if(c<3){this.indexedTins=void 0;return}let i=[],f=[];const g=r.features.map(d=>{let a=[];return Q(d)[0].map(s=>{i.length===0?i=[Array.from(s),Array.from(s)]:(s[0]<i[0][0]&&(i[0][0]=s[0]),s[0]>i[1][0]&&(i[1][0]=s[0]),s[1]<i[0][1]&&(i[0][1]=s[1]),s[1]>i[1][1]&&(i[1][1]=s[1])),a.length===0?a=[Array.from(s),Array.from(s)]:(s[0]<a[0][0]&&(a[0][0]=s[0]),s[0]>a[1][0]&&(a[1][0]=s[0]),s[1]<a[0][1]&&(a[0][1]=s[1]),s[1]>a[1][1]&&(a[1][1]=s[1]))}),a}),h=(i[1][0]-i[0][0])/c,l=(i[1][1]-i[0][1])/c,y=g.reduce((d,a,s)=>{const m=C(a[0][0],i[0][0],h,c),_=C(a[1][0],i[0][0],h,c),p=C(a[0][1],i[0][1],l,c),M=C(a[1][1],i[0][1],l,c);for(let w=m;w<=_;w++){d[w]||(d[w]=[]);for(let v=p;v<=M;v++)d[w][v]||(d[w][v]=[]),d[w][v].push(s)}return d},[]),o=n.features.map(d=>{let a=[];return Q(d)[0].map(s=>{f.length===0?f=[Array.from(s),Array.from(s)]:(s[0]<f[0][0]&&(f[0][0]=s[0]),s[0]>f[1][0]&&(f[1][0]=s[0]),s[1]<f[0][1]&&(f[0][1]=s[1]),s[1]>f[1][1]&&(f[1][1]=s[1])),a.length===0?a=[Array.from(s),Array.from(s)]:(s[0]<a[0][0]&&(a[0][0]=s[0]),s[0]>a[1][0]&&(a[1][0]=s[0]),s[1]<a[0][1]&&(a[0][1]=s[1]),s[1]>a[1][1]&&(a[1][1]=s[1]))}),a}),u=(f[1][0]-f[0][0])/c,b=(f[1][1]-f[0][1])/c,x=o.reduce((d,a,s)=>{const m=C(a[0][0],f[0][0],u,c),_=C(a[1][0],f[0][0],u,c),p=C(a[0][1],f[0][1],b,c),M=C(a[1][1],f[0][1],b,c);for(let w=m;w<=_;w++){d[w]||(d[w]=[]);for(let v=p;v<=M;v++)d[w][v]||(d[w][v]=[]),d[w][v].push(s)}return d},[]);this.indexedTins={forw:{gridNum:c,xOrigin:i[0][0],yOrigin:i[0][1],xUnit:h,yUnit:l,gridCache:y},bakw:{gridNum:c,xOrigin:f[0][0],yOrigin:f[0][1],xUnit:u,yUnit:b,gridCache:x}}}transform(e,r,n){if(r&&this.strict_status==O.STATUS_ERROR)throw'Backward transform is not allowed if strict_status == "strict_error"';this.yaxisMode==O.YAXIS_FOLLOW&&r&&(e=[e[0],-1*e[1]]);const c=W(e);if(this.bounds&&!r&&!n&&!L(c,this.boundsPolygon))return!1;const i=r?this.tins.bakw:this.tins.forw,f=r?this.indexedTins.bakw:this.indexedTins.forw,g=r?this.vertices_params.bakw:this.vertices_params.forw,h=r?this.centroid.bakw:this.centroid.forw,l=r?this.pointsWeightBuffer.bakw:this.pointsWeightBuffer.forw;let y,o;this.stateFull&&(this.stateBackward==r?y=this.stateTriangle:(this.stateBackward=r,this.stateTriangle=void 0),o=b=>{this.stateTriangle=b});let u=tt(c,i,f,g,h,l,y,o);if(this.bounds&&r&&!n){const b=W(u);if(!L(b,this.boundsPolygon))return!1}else this.yaxisMode==O.YAXIS_FOLLOW&&!r&&(u=[u[0],-1*u[1]]);return u}}S.Transform=O,S.counterTri=_t,S.format_version=Bt,S.normalizeEdges=rt,S.rotateVerticesTriangle=xt,S.transformArr=tt,Object.defineProperty(S,Symbol.toStringTag,{value:"Module"})});
